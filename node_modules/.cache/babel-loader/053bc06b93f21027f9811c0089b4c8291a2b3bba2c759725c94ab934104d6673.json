{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector, gridRowGroupsToFetchSelector } from './gridRowsSelector';\nimport { useTimeout } from '../../utils/useTimeout';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutogeneratedRowNode, GRID_ROOT_GROUP_ID, GRID_ID_AUTOGENERATED, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel, computeRowsUpdates } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  const isDataSourceAvailable = !!props.unstable_dataSource;\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: isDataSourceAvailable ? [] : props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: isDataSourceAvailable ? true : props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const lastRowCount = React.useRef(props.rowCount);\n  const timeout = useTimeout();\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    const node = apiRef.current.getRowNode(id);\n    if (node && isAutogeneratedRowNode(node)) {\n      return {\n        [GRID_ID_AUTOGENERATED]: id\n      };\n    }\n    return null;\n  }, [apiRef]);\n  const getRowIdProp = props.getRowId;\n  const getRowId = React.useCallback(row => {\n    if (GRID_ID_AUTOGENERATED in row) {\n      return row[GRID_ID_AUTOGENERATED];\n    }\n    if (getRowIdProp) {\n      return getRowIdProp(row);\n    }\n    return row.id;\n  }, [getRowIdProp]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref, index) => {\n    let {\n      id\n    } = _ref;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(_ref2 => {\n    let {\n      cache,\n      throttle\n    } = _ref2;\n    const run = () => {\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef),\n          previousGroupsToFetch: gridRowGroupsToFetchSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    timeout.clear();\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.start(throttleRemainingTimeMs, run);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);\n\n  /**\n   * API METHODS\n   */\n  const setRows = React.useCallback(rows => {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error(['MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const updateServerRows = React.useCallback((updates, groupKeys) => {\n    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows,\n      groupKeys: groupKeys !== null && groupKeys !== void 0 ? groupKeys : []\n    });\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [props.getRowId, throttledRowsChange, apiRef]);\n  const setLoading = React.useCallback(loading => {\n    if (loading === props.loading) {\n      return;\n    }\n    logger.debug(\"Setting loading to \".concat(loading));\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        loading\n      })\n    }));\n    apiRef.current.caches.rows.loadingPropBeforePartialUpdates = loading;\n  }, [props.loading, apiRef, logger]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => {\n      var _idRowsLookup$id;\n      return [id, (_idRowsLookup$id = idRowsLookup[id]) !== null && _idRowsLookup$id !== void 0 ? _idRowsLookup$id : {}];\n    }));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(\"MUI X: No row with id #\".concat(id, \" found.\"));\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI X: Only group nodes can be expanded or collapsed.');\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) !== null && _gridRowTreeSelector$ !== void 0 ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(_ref3 => {\n    let {\n      skipAutoGeneratedRows = true,\n      groupId,\n      applySorting,\n      applyFiltering\n    } = _ref3;\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(\"MUI X: No row with id #\".concat(rowId, \" found.\"));\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(\"MUI X: The row reordering do not support reordering of grouped rows yet.\");\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(\"MUI X: The row reordering do not support reordering of footer or grouping rows.\");\n    }\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(\"Moving row \".concat(rowId, \" to index \").concat(targetIndex));\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error(['MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    const seenIds = new Set();\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [removedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      if (!seenIds.has(removedRowId)) {\n        delete dataRowIdToModelLookup[removedRowId];\n        delete dataRowIdToIdLookup[removedRowId];\n        delete tree[removedRowId];\n      }\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n      seenIds.add(rowId);\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    const dataRowIds = rootGroupChildren.filter(childId => {\n      var _tree$childId;\n      return ((_tree$childId = tree[childId]) === null || _tree$childId === void 0 ? void 0 : _tree$childId.type) === 'leaf';\n    });\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    setLoading,\n    getRowId,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n  const rowProPrivateApi = {\n    updateServerRows\n  };\n\n  /**\n   * EVENTS\n   */\n  const groupRows = React.useCallback(() => {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    let cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n  useGridApiMethod(apiRef, rowProPrivateApi, 'private');\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    var _props$rows;\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    let isRowCountPropUpdated = false;\n    if (props.rowCount !== lastRowCount.current) {\n      isRowCountPropUpdated = true;\n      lastRowCount.current = props.rowCount;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      if (!isRowCountPropUpdated) {\n        return;\n      }\n    }\n    logger.debug(\"Updating all rows, new length \".concat((_props$rows = props.rows) === null || _props$rows === void 0 ? void 0 : _props$rows.length));\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowGroupingNameSelector","gridRowTreeDepthsSelector","gridDataRowIdsSelector","gridRowsDataRowIdToIdLookupSelector","gridRowMaximumTreeDepthSelector","gridRowGroupsToFetchSelector","useTimeout","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","isAutogeneratedRowNode","GRID_ROOT_GROUP_ID","GRID_ID_AUTOGENERATED","updateCacheWithNewRows","getTopLevelRowCount","getRowIdFromRowModel","computeRowsUpdates","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","isDataSourceAvailable","unstable_dataSource","current","caches","rows","getRowId","loading","rowCount","rowCountProp","loadingProp","previousTree","previousTreeDepths","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","lastRowCount","timeout","getRow","useCallback","id","model","node","getRowNode","getRowIdProp","row","lookup","useMemo","reduce","acc","_ref","index","throttledRowsChange","_ref2","cache","throttle","run","setState","previousGroupsToFetch","publishEvent","forceUpdate","clear","throttleRemainingTimeMs","throttleRowsMs","start","setRows","debug","concat","length","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","nonPinnedRowsUpdates","previousCache","updateServerRows","groupKeys","setLoading","loadingPropBeforePartialUpdates","getRowModels","dataRows","idRowsLookup","Map","map","_idRowsLookup$id","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","type","newNode","childrenExpanded","tree","_gridRowTreeSelector$","getRowGroupChildren","_ref3","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","push","filteredRowsLookup","filter","childId","setRowIndex","rowId","targetIndex","parent","group","instanceId","allRows","oldIndex","updatedRows","splice","replaceRows","firstRowToRender","newRows","treeDepth","dataRowIdToModelLookup","dataRowIdToIdLookup","rootGroup","rootGroupChildren","seenIds","Set","i","rowModel","removedRowId","has","rowTreeNodeConfig","groupingKey","add","dataRowIds","_tree$childId","rowApi","unstable_replaceRows","rowProApi","rowProPrivateApi","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","getActiveStrategy","applyHydrateRowsProcessor","response","unstable_applyPipeProcessors","treeDepths","totalTopLevelRowCount","isFirstRender","useEffect","_props$rows","isRowCountPropUpdated","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","isNewRowCountAlreadyInState","rowCountPropBeforePartialUpdates","totalRowCount","Math","max"],"sources":["E:/OneDrive - delaPlex/Project/BlueBerry/ChatGpt/21Aug24/Blueberry-bot/frontend/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector, gridRowGroupsToFetchSelector } from './gridRowsSelector';\nimport { useTimeout } from '../../utils/useTimeout';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutogeneratedRowNode, GRID_ROOT_GROUP_ID, GRID_ID_AUTOGENERATED, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel, computeRowsUpdates } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  const isDataSourceAvailable = !!props.unstable_dataSource;\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: isDataSourceAvailable ? [] : props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: isDataSourceAvailable ? true : props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const lastRowCount = React.useRef(props.rowCount);\n  const timeout = useTimeout();\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    const node = apiRef.current.getRowNode(id);\n    if (node && isAutogeneratedRowNode(node)) {\n      return {\n        [GRID_ID_AUTOGENERATED]: id\n      };\n    }\n    return null;\n  }, [apiRef]);\n  const getRowIdProp = props.getRowId;\n  const getRowId = React.useCallback(row => {\n    if (GRID_ID_AUTOGENERATED in row) {\n      return row[GRID_ID_AUTOGENERATED];\n    }\n    if (getRowIdProp) {\n      return getRowIdProp(row);\n    }\n    return row.id;\n  }, [getRowIdProp]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(({\n    cache,\n    throttle\n  }) => {\n    const run = () => {\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef),\n          previousGroupsToFetch: gridRowGroupsToFetchSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    timeout.clear();\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.start(throttleRemainingTimeMs, run);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);\n\n  /**\n   * API METHODS\n   */\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error(['MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const updateServerRows = React.useCallback((updates, groupKeys) => {\n    const nonPinnedRowsUpdates = computeRowsUpdates(apiRef, updates, props.getRowId);\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows,\n      groupKeys: groupKeys ?? []\n    });\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [props.getRowId, throttledRowsChange, apiRef]);\n  const setLoading = React.useCallback(loading => {\n    if (loading === props.loading) {\n      return;\n    }\n    logger.debug(`Setting loading to ${loading}`);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        loading\n      })\n    }));\n    apiRef.current.caches.rows.loadingPropBeforePartialUpdates = loading;\n  }, [props.loading, apiRef, logger]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => [id, idRowsLookup[id] ?? {}]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(`MUI X: No row with id #${id} found.`);\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI X: Only group nodes can be expanded or collapsed.');\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => gridRowTreeSelector(apiRef)[id] ?? null, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(`MUI X: No row with id #${rowId} found.`);\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI X: The row reordering do not support reordering of grouped rows yet.`);\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI X: The row reordering do not support reordering of footer or grouping rows.`);\n    }\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error(['MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    const seenIds = new Set();\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [removedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      if (!seenIds.has(removedRowId)) {\n        delete dataRowIdToModelLookup[removedRowId];\n        delete dataRowIdToIdLookup[removedRowId];\n        delete tree[removedRowId];\n      }\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n      seenIds.add(rowId);\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId]?.type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    setLoading,\n    getRowId,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n  const rowProPrivateApi = {\n    updateServerRows\n  };\n\n  /**\n   * EVENTS\n   */\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n  useGridApiMethod(apiRef, rowProPrivateApi, 'private');\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    let isRowCountPropUpdated = false;\n    if (props.rowCount !== lastRowCount.current) {\n      isRowCountPropUpdated = true;\n      lastRowCount.current = props.rowCount;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      if (!isRowCountPropUpdated) {\n        return;\n      }\n    }\n    logger.debug(`Updating all rows, new length ${props.rows?.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}